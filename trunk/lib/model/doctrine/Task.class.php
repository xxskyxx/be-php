<?php

/**
 * Task
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    sf
 * @subpackage model
 * @author     VozdvIN
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Task extends BaseTask implements IStored, IAuth
{

  //// IStored ////

  public static function all()
  {
    return Utils::all('Task');
  }

  public static function byId($id)
  {
    return Utils::byId('Task', $id);
  }

  //// IAuth ////

  static function isModerator(WebUser $account)
  {
    return Game::isModerator($account);
  }

  function canBeManaged(WebUser $account)
  {
    return $this->Game->canBeManaged($account);
  }

  function canBeObserved(WebUser $account)
  {
    return $this->Game->canBeObserved($account);
  }

  //// Public ////

  /**
   * Возвращает список состояний заданий команд, которые получили это задание,
   * но еще не ознакомились с ним.
   *
   * @return  Doctrine_Collection   Или false, если не найдено.
   */
  public function getQueuedTaskStates()
  {
    $res = new Doctrine_Collection('TaskState');
    foreach ($this->taskStates as $taskState)
    {
      if ($taskState->status < TaskState::TASK_ACCEPTED)
      {
        $res->add($taskState);
      }
    }
    return ($res->count() > 0) ? $res : false;
  }

  /**
   * Возвращает список состояний заданий команд, которые выполняют это задание.
   *
   * @return  Doctrine_Collection   Или false, если не найдено.
   */
  public function getActiveTaskStates()
  {
    $res = new Doctrine_Collection('TaskState');
    foreach ($this->taskStates as $taskState)
    {
      if (($taskState->status >= TaskState::TASK_ACCEPTED)
          && ($taskState->status < TaskState::TASK_DONE))
      {
        $res->add($taskState);
      }
    }
    return ($res->count() > 0) ? $res : false;
  }

  /**
   * Возвращает текущий приоритет задания, не зависящий от конкретной команды.
   *
   * @return integer
   */
  public function getPrioritySelf()
  {
    $activeTaskStates = $this->getActiveTaskStates();
    if ($activeTaskStates === false)
    {
      // Нет выполняющих команд, проверим сколько в очереди
      $queuedTaskStates = $this->getQueuedTaskStates();
      if ($queuedTaskStates === false)
      {
        // Задание никому не выдано
        return $this->priority_free;
      }
      else
      {
        // Задание выдано по крайней мере одной команде
        return $this->priority_queued;
      }
    }
    else
    {
      // Есть выполняющие команды
      $res = $this->priority_busy + $activeTaskStates->count()*$this->priority_per_team;
      if (($this->max_teams > 0) && ($activeTaskStates->count() >= $this->max_teams))
      {
        $res += $this->priority_filled;
      }
      return $res;
    }
  }

  /**
   * Возвращает приоритет перехода с данного задания на указанное.
   * Если особых настроек нет, то возвращает 0.
   * Для перехода самого на себя возвращает false.
   *
   * @param   Task      $targetTask   Задание, на переход к которому надо найти приоритет
   * @return  integer
   */
  public function getPriorityJump(Task $targetTask)
  {
    if ($targetTask->id == $this->id)
    {
      return false;
    }
    foreach ($this->taskConstraints as $taskConstraint)
    {
      if ($taskConstraint->target_task_id == $targetTask->id)
      {
        return $taskConstraint->priority_shift;
      }
    }
    return 0;
  }

  /**
   * Возвращает полный приоритет перехода с этого на указанное задание.
   * Для перехода самого на себя возвращает false.
   *
   * @param   Task  $targetTask
   * @param   Team  $usingTeam
   * @return  integer
   */
  public function getPriorityOn(Task $targetTask)
  {
    if ($targetTask->id == $this->id)
    {
      return false;
    }
    return $targetTask->getPrioritySelf() + $this->getPriorityJump($targetTask);
  }

  /**
   * Проверяет, что на задани находится максимальное количество команд или более.
   *
   * @return  boolean
   */
  public function isFilled()
  {
    if ($this->max_teams == 0)
    {
      return false;
    }
    $teams = $this->getActiveTaskStates();
    return (!$teams) ? false : ($teams->count() >= $this->max_teams);
  }

  /**
   * Возвращает все ответы, которая указанная команда должна ввести для зачета.
   *
   * @param   Team                          $team   Команда, чьи ответы надо вернуть
   * 
   * @return  Doctrine_Collection<Answer>
   */
  public function getTargetAnswersForTeam(Team $team)
  {
    $res = new Doctrine_Collection('Answer');
    foreach ($this->answers as $answer)
    {
      //Ответ не является персональным
      if (($answer->team_id === null) || ($answer->team_id <= 0))
      {
        $res->add($answer);
      }
      //Ответ персональный и он для этой команды
      elseif (($answer->team_id > 0) && ($answer->team_id == $team->id))
      {
        $res->add($answer);
      }
    }
    return $res;
  }

  /**
   * Устанаваливает значения по умолчанию для тех полей, которые не заполнены.
   */
  public function initDefaults()
  {
    if ($this->time_per_task_local <= 0)
    {
      $this->time_per_task_local = $this->Game->time_per_task;
    }
    if ($this->try_count_local <= 0)
    {
      $this->try_count_local = $this->Game->try_count;
    }
    if ($this->tips->count() <= 0)
    {
      $tip = new Tip();
      $tip->task_id = $this->id;
      $tip->name = $this->Game->task_define_default_name;
      $tip->define = 'Формулировка_задания_'.$this->name;
      $tip->delay = 0;
      $this->tips->add($tip);
    }
    if ($this->answers->count() <= 0)
    {
      $answer = new Answer();
      $answer->task_id = $this->id;
      $answer->name = 'Ответ';
      $answer->info = '0';
      $answer->value = '0000';
      $this->answers->add($answer);
    }
  }

  /**
   * Устанавливает всем существующим фильтрам перехода признак ручного выбора.
   * 
   * @param   boolean   $value    Устанавливаемое значение
   * @param   WebUser   $account  Авторизация операции
   */
  public function allTransitionsSetManual($value, WebUser $account)
  {
    if ( ! $this->canBeManaged($account))
    {
      throw new Exception(Utils::cannotMessage($account->login, 'редактировать фильтры переходов'));
    }
    foreach ($this->taskTransitions as $taskTransition)
    {
      $taskTransition->manual_selection = $value;
    }
    $this->save();
  }
  
  /**
   * Создает безусловные переходы на все остальные задания.
   * 
   * @param   WebUser   $account  Авторизация операции
   */
  public function addTransitionsToAllTasks(WebUser $account)
  {
    if ( ! $this->canBeManaged($account))
    {
      throw new Exception(Utils::cannotMessage($account->login, 'редактировать фильтры переходов'));
    }
    foreach ($this->Game->tasks as $task)
    {
      if (($this->id != $task->id) && ( ! $this->hasTransitionToTask($task)))
      {
        $newTransition = new TaskTransition();
        $newTransition->task_id = $this->id;
        $newTransition->target_task_id = $task->id;
        $this->taskTransitions->add($newTransition);
      }
    }
    $this->save();
  }

  /**
   * Возвращает список заданий доступных для перехода,
   * если успешность выполнения данного задания равна указанному значению.
   * 
   * @param   boolean   $currentTaskResult    Успешность задания, на основе этого значения сработают фильтры
   * @param   boolean   $forManualSelectOnly  Отбирать только задания с признаком ручного выбора.
   * 
   * @return  Doctrine_Collection<Task>
   */
  public function getNextTasks($currentTaskResult, $forManualSelectOnly)
  {
    $result = new Doctrine_Collection('Task');
    foreach ($this->taskTransitions as $taskTransition)
    {
      if (
           ($taskTransition->isTransitionPassForResult($currentTaskResult))
           &&
           (
             ( ! $forManualSelectOnly)
             ||
             ($taskTransition->manual_selection == $forManualSelectOnly)
           )
         )
      {
        $targetTask = $taskTransition->getTargetTaskSafe();
        if ($targetTask)
        {
          $result->add($targetTask);
        }
      }
    }
    return $result;
  }
  
  /**
   * Ищет в указанном списке ответ с заданным значением.
   * 
   * @param   string                  $answerValue      значение для поиска
   * @param   Doctrine_Collection     $correctAnswers   список ворректных ответов
   * 
   * @return  Doctrine_Record<Answer>                   Найденный ответ, или False если не найден.
   */
  public static function answerForValue($answerValue, Doctrine_Collection $correctAnswers)
  {
    $clearValue = trim($answerValue);
    foreach ($correctAnswers as $correctAnswer)
    {
      if (strcasecmp($clearValue, $correctAnswer->value) == 0)
      {
        return $correctAnswer;
      }
    }
    return false;
  }
  
  /**
   * Убирает из исходного списка заданий все задания, встречающиеся во втором списке.
   *
   * @param   Doctrine_Collection<Task>   $sourceTaskList       Исходный список
   * @param   Doctrine_Collection<Task>   $tasksToExcludeList   Список заданий, которые нужно убрать из исходного
   * 
   * @return  Doctrine_Collection<Task>
   */
  public static function excludeTasks(Doctrine_Collection $sourceTaskList, Doctrine_Collection $tasksToExcludeList)
  {
    $result = new Doctrine_Collection('Task');
    foreach ($sourceTaskList as $sourceTask)
    {
      if ( ! Task::isTaskInList($sourceTask, $tasksToExcludeList))
      $result->add($sourceTask);
    }
    return $result;
  }

  /**
   * Проверяет, присутствует ли указанное заданеи в указанном списке.
   *
   * @param   Task                  $task       Задание которое искать
   * @param   Doctrine_Collection   $taskList   Список где искать
   *
   * @return  boolean
   */
  public static function isTaskInList(Task $targetTask, Doctrine_Collection $taskList)
  {
    foreach ($taskList as $task)
    {
      if ($task->id == $targetTask->id)
      {
        return true;
      }
    }
    return false;
  }

  //// Self ////
  
  /**
   * Проверяет, задан ли фильтр перехода на указанное задание.
   * 
   * @param   Task  $task 
   * 
   * @return  boolean
   */
  protected function hasTransitionToTask(Task $task)
  {
    foreach ($this->taskTransitions as $taskTransition)
    {
      $targetTask = $taskTransition->getTargetTaskSafe();
      if ($targetTask)
      {
        if ($targetTask->id == $task->id)
        {
          return true;
        }
      }
    }
    return false;
  }
}