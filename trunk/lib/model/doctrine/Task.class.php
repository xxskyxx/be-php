<?php

/**
 * Task
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    sf
 * @subpackage model
 * @author     VozdvIN
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Task extends BaseTask implements IStored, IAuth
{

  //// IStored ////

  public static function all()
  {
    return Utils::all('Task');
  }

  public static function byId($id)
  {
    return Utils::byId('Task', $id);
  }

  //// IAuth ////

  static function isModerator(WebUser $account)
  {
    return Game::isModerator($account);
  }

  function canBeManaged(WebUser $account)
  {
    return $this->Game->canBeManaged($account);
  }

  function canBeObserved(WebUser $account)
  {
    return $this->Game->canBeObserved($account);
  }

  //// Public ////

  /**
   * Возвращает список состояний заданий команд, которые получили это задание,
   * но еще не ознакомились с ним.
   *
   * @return  Doctrine_Collection   Или false, если не найдено.
   */
  public function getQueuedTaskStates()
  {
    $res = new Doctrine_Collection('TaskState');
    foreach ($this->taskStates as $taskState)
    {
      if ($taskState->status < TaskState::TASK_ACCEPTED)
      {
        $res->add($taskState);
      }
    }
    return ($res->count() > 0) ? $res : false;
  }

  /**
   * Возвращает список состояний заданий команд, которые выполняют это задание.
   *
   * @return  Doctrine_Collection   Или false, если не найдено.
   */
  public function getActiveTaskStates()
  {
    $res = new Doctrine_Collection('TaskState');
    foreach ($this->taskStates as $taskState)
    {
      if (($taskState->status >= TaskState::TASK_ACCEPTED)
          && ($taskState->status < TaskState::TASK_DONE))
      {
        $res->add($taskState);
      }
    }
    return ($res->count() > 0) ? $res : false;
  }

  /**
   * Возвращает текущий приоритет задания, не зависящий от конкретной команды.
   *
   * @return integer
   */
  public function getPrioritySelf()
  {
    $activeTaskStates = $this->getActiveTaskStates();
    if ($activeTaskStates === false)
    {
      // Нет выполняющих команд, проверим сколько в очереди
      $queuedTaskStates = $this->getQueuedTaskStates();
      if ($queuedTaskStates === false)
      {
        // Задание никому не выдано
        return $this->priority_free;
      }
      else
      {
        // Задание выдано по крайней мере одной команде
        return $this->priority_queued;
      }
    }
    else
    {
      // Есть выполняющие команды
      $res = $this->priority_busy + $activeTaskStates->count()*$this->priority_per_team;
      if (($this->max_teams > 0) && ($activeTaskStates->count() >= $this->max_teams))
      {
        $res += $this->priority_filled;
      }
      return $res;
    }
  }

  /**
   * Возвращает приоритет перехода с данного задания на указанное.
   * Если особых настроек нет, то возвращает 0.
   * Для перехода самого на себя возвращает false.
   *
   * @param   Task      $targetTask   Задание, на переход к которому надо найти приоритет
   * @return  integer
   */
  public function getPriorityJump(Task $targetTask)
  {
    if ($targetTask->id == $this->id)
    {
      return false;
    }
    foreach ($this->taskConstraints as $taskConstraint)
    {
      if ($taskConstraint->target_task_id == $targetTask->id)
      {
        return $taskConstraint->priority_shift;
      }
    }
    return 0;
  }

  /**
   * Возвращает полный приоритет перехода с этого на указанное задание.
   * Для перехода самого на себя возвращает false.
   *
   * @param   Task  $targetTask
   * @param   Team  $usingTeam
   * @return  integer
   */
  public function getPriorityOn(Task $targetTask)
  {
    if ($targetTask->id == $this->id)
    {
      return false;
    }
    return $targetTask->getPrioritySelf() + $this->getPriorityJump($targetTask);
  }

  /**
   * Проверяет, что на задани находится максимальное количество команд или более.
   *
   * @return  boolean
   */
  public function isFilled()
  {
    if ($this->max_teams == 0)
    {
      return false;
    }
    $teams = $this->getActiveTaskStates();
    return (!$teams) ? false : ($teams->count() >= $this->max_teams);
  }

  /**
   * Возвращает все ответы, которая указанная команда должна ввести для зачета.
   *
   * @param   Team                          $team   Команда, чьи ответы надо вернуть
   * 
   * @return  Doctrine_Collection<Answer>
   */
  public function getTargetAnswersForTeam(Team $team)
  {
    $res = new Doctrine_Collection('Answer');
    foreach ($this->answers as $answer)
    {
      //Ответ не является персональным
      if (($answer->team_id === null) || ($answer->team_id <= 0))
      {
        $res->add($answer);
      }
      //Ответ персональный и он для этой команды
      elseif (($answer->team_id > 0) && ($answer->team_id == $team->id))
      {
        $res->add($answer);
      }
    }
    return $res;
  }

  /**
   * Устанаваливает значения по умолчанию для тех полей, которые не заполнены.
   */
  public function initDefaults()
  {
    if ($this->time_per_task_local <= 0)
    {
      $this->time_per_task_local = $this->Game->time_per_task;
    }
    if ($this->try_count_local <= 0)
    {
      $this->try_count_local = $this->Game->try_count;
    }
    if ($this->tips->count() <= 0)
    {
      $tip = new Tip();
      $tip->task_id = $this->id;
      $tip->name = $this->Game->task_define_default_name;
      $tip->define = 'Формулировка_задания_'.$this->name;
      $tip->delay = 0;
      $this->tips->add($tip);
    }
    if ($this->answers->count() <= 0)
    {
      $answer = new Answer();
      $answer->task_id = $this->id;
      $answer->name = 'Ответ';
      $answer->info = '0';
      $answer->value = '0000';
      $this->answers->add($answer);
    }
  }

  /**
   * Ищет в указанном списке ответ с заданным значением.
   * 
   * @param   string                  $answerValue      значение для поиска
   * @param   Doctrine_Collection     $correctAnswers   список ворректных ответов
   * 
   * @return  Doctrine_Record<Answer>                   Найденный ответ, или False если не найден.
   */
  public static function answerForValue($answerValue, Doctrine_Collection $correctAnswers)
  {
    $clearValue = trim($answerValue);
    foreach ($correctAnswers as $correctAnswer)
    {
      if (strcasecmp($clearValue, $correctAnswer->value) == 0)
      {
        return $correctAnswer;
      }
    }
    return false;
  }
  
}