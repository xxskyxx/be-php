<?php

/**
 * TeamState
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    sf
 * @subpackage model
 * @author     VozdvIN
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class TeamState extends BaseTeamState implements IStored, IAuth
{
  const TEAM_WAIT_GAME = 0;
  const TEAM_WAIT_START = 100;
  const TEAM_WAIT_TASK = 200;
  const TEAM_HAS_TASK = 300;
  const TEAM_FINISHED = 900;

  //// IStored ////

  static function all()
  {
    return Utils::all('TeamState');
  }

  static function byId($id)
  {
    return Utils::byId('TeamState', $id);
  }

  //// IAuth ////

  static function isModerator(WebUser $account)
  {
    return Game::isModerator($account);
  }

  function canBeManaged(WebUser $account)
  {
    return $this->Game->canBeManaged($account);
  }

  function canBeObserved(WebUser $account)
  {
    return $this->Game->canBeObserved($account) || $this->Team->canBeObserved($account);
  }
  
  //// Public ////
  // Info

  /**
   * Проверяет, обладает ли пользователь правом обновлять состояние команды
   * 
   * @param WebUser $account 
   */
  function canUpdateState(WebUser $account)
  {
    if (!$this->Game->teams_can_update)
    {
      // Пересчет состояния допустим только руководителем игры, проверим
      return $this->canBeManaged($account);
    }
    else
    {
      // Пересчет состояния допустим как руководителем, так и любым игроком
      return ($this->Team->isPlayer($account)) || $this->canBeManaged($account);
      /* Проверка на то, что команда зарегистрирована не нужна, так как
       * экземпляр состояния команды создается только при регистрации.
       */
    }    
  }
  
  /**
   * Описывает состояние команды по коду статуса
   *
   * @param   integer   $aStatus  Код статуса
   * @return  string
   */
  public function describeStatus()
  {
    switch ($this->status)
    {
      case TeamState::TEAM_WAIT_GAME: return 'Ждет игры';
        break;
      case TeamState::TEAM_WAIT_START: return 'Ждет старта';
        break;
      case TeamState::TEAM_WAIT_TASK: return 'Ждет задания';
        break;
      case TeamState::TEAM_HAS_TASK: return 'Есть задание';
        break;
      case TeamState::TEAM_FINISHED: return 'Финишировала';
        break;
      default: return 'Неизвестно';
        break;
    }
  }

  /**
   * Возвращает фактическое время старта команды с учетом фактического времени старта игры (Ввремя Unix).
   *
   * @return  integer
   */
  public function getActualStartDateTime()
  {
    return ($this->Game->started_at > 0)
        ? $this->Game->started_at + $this->start_delay * 60
        : Timing::strToDate($this->Game->start_datetime) + $this->start_delay * 60;
  }

  /**
   * Возвращает фактическое время финиша команды (время Unix).
   * Только для справок!
   *
   * @return  integer
   */
  public function getTeamStopTime()
  {
    return ($this->started_at > 0)
        ? time() + ($this->Game->time_per_game * 60 - $this->getGameSpentTimeCurrent())
        : 0;
  }

  /**
   * Возвращает личное время команды, затраченное на игру (время Unix).
   * Основа для определения момента финиша команды!
   *
   * @return  integer
   */
  public function getGameSpentTimeCurrent()
  {
    if ($this->started_at == 0)
    {
      return 0;
    }
    //Обновим данные о затратах времени на задания.
    //Данные включают рассчет длительности текущего задания, если оно есть.
    $this->updateTime();
    return $this->game_time_spent;
  }

  /**
   * Возвращает статус текущего задания, если оно есть, иначе false.
   * Внимание! Технические подробности:
   * Если ссылка на текущее задание окажется битая, то сначала попытается ее
   * исправить и при успехе вернет задание;
   * если исправить не удастся, обнулит ссылку и вернет false.
   *
   * @return  TaskState
   */
  public function getCurrentTaskState()
  {
    if ($this->task_state_id <= 0)
    {
      return false;
    }
    //Попробуем найти по ссылке
    $res = TaskState::byId($this->task_state_id);
    if (!$res)
    {
      //Ссылка на состояние задания устарела. Удалим ее.
      $this->task_state_id = 0;
      $res = false;
      // Внимание! Ссылка могла устареть, если состояние БД было восстановелено из архива.
      // Т.е. ссылка неверная, а реально у команды есть текущее задание.
      // Это задание можно найти по отсутствию признака закрытия. Попробуем.
      foreach ($this->taskStates as $taskState)
      {
        if (!$taskState->closed)
        {
          //Нашли незакрытое задание, запомним его как текущее.
          $this->task_state_id = $taskState->id;
          $this->save();
          $res = $taskState;
          break;
        }
      }
    }
    return $res;
  }

  /**
   * Возвращает статус последнего завершенного задания, если оно есть, иначе false.
   *
   * @return  TaskState
   */
  public function getLastDoneTaskState()
  {
    $res = false;
    if ($this->taskStates->count() <= 0)
    {
      return false;
    }
    $doneAt = 0;
    foreach ($this->taskStates as $taskState)
    {
      if ($taskState->closed
          && ($doneAt <= $taskState->done_at))
      {
        $doneAt = $taskState->done_at;
        $res = $taskState;
      }
    }
    return $res;
  }

  /**
   * Проверяет, может ли команда перейти на указанное задание.
   * 
   * @param   Task  $task 
   * @return  boolean
   */
  public function canGetTask(Task $task)
  {
    if ($this->isKnownTask($task) || $task->locked)
    {
      return false;
    }
    //TODO: в будущем должна учитывать задания, входящие в последовательности:
    //- Если предыдущее задание не входило в цепочку или оно ее закончило, то доступны:
    //  - любые неизвестные одиночные
    //  - любые неизвестные, начинающие цепочки.
    //- Иначе доступно только следующее задание в цепочке.
    //  - ??!! Что делать, если следующее задание в цепочке блокировано?
    return true;
  }
  
  /**
   * Возвращает приоритет перехода на указанное задание.
   * Если переход на это задание невозможен - вернет false.
   * 
   * @param   Task      $task   Задание, приоритет перехода на которое надо посчитать.
   * 
   * @return  integer
   */
  public function getPriorityOfTask(Task $task)
  {
    if ((!$this->canGetTask($task))
        || ($this->status == TeamState::TEAM_FINISHED))
    {
      return false;
    }
    if ($currentTask = $this->getCurrentTaskState())
    {
      $baseTask = $currentTask;
    }
    elseif ($lastDoneTask = $this->getLastDoneTaskState())
    {
      $baseTask = $lastDoneTask;
    }
    else
    {
      $baseTask = false;
    }
    if (!$baseTask)
    {
      //Команда только стартовала, поэтому все определяется собственным приоритетом задания.
      return $task->getPrioritySelf();
    }
    else
    {
      //TODO: Здесь нужна корректировка приоритета, зависящая от команды и ее истории заданий.
      return $baseTask->Task->getPriorityOn($task);
    }    
  }
  
  /**
   * Возвращает список доступных для выдачи заданий.
   *
   * @return  Doctrine_Collection   Или false, если нет неизвестных заданий.
   */
  public function getAvailableTasks()
  {
    $res = new Doctrine_Collection('Task');
    foreach ($this->Game->tasks as $task)
    {
      if ($this->canGetTask($task))
      {
        $res->add($task);
      }
    }
    return ($res->count() > 0)
        ? $res
        : false;
  }

  /**
   * Возвращает результаты команды в виде массива:
   * - ключи:
   *    - 'id' - БД-ключ команды
   *    - 'points' - набранные очки
   *    - 'time' - затраченное время
   * - данные - соответствущие значения
   */
  public function getTeamResults()
  {
    $res = array();
    $res['id'] = $this->team_id;
    $res['points'] = 0;
    $res['time'] = 0;
    foreach ($this->taskStates as $taskState)
    {
      $taskRes = $taskState->getTaskResults();
      $res['points'] += $taskRes['points'];
      $res['time'] += $taskRes['time'];
    }
    return $res;
  }

  /**
   * Проверяет, выдавалось ли указанное задание команде.
   *
   * @param   Task      $task   Задание на проверку.
   * @return  boolean
   */
  public function isKnownTask(Task $task)
  {
    foreach ($this->taskStates as $taskState)
    {
      if ($task->id == $taskState->task_id)
      {
        return true;
      }
    }
    return false;
  }

  /**
   * Ищет состояние задания, соответствующее указанному заданию.
   *
   * @param   Task              $task   Задание на проверку.
   * @return  Doctrine_record           Или false, если команда не знает задания.
   */
  public function findKnownTaskState(Task $task)
  {
    foreach ($this->taskStates as $taskState)
    {
      if ($task->id == $taskState->task_id)
      {
        return $taskState;
      }
    }
    return false;
  }

  // Action

  /**
   * Обновляет состояние команды (сохраняет в БД).
   *
   * @param   WebUser   $actor      Исполнитель
   * @return  mixed                 True при успехе, иначе строка с ошибкой.
   */
  public function updateState(WebUser $actor)
  {
    if (!$this->Game->isActive()
        || !$this->isPlayingNow()
        || !Timing::isExpired(time(), Game::MIN_UPDATE_INERVAL, $this->team_last_update))
    {
      return true;
    }

    if (!$this->canUpdateState($actor))
    {
      return Utils::cannotMessage($actor->login, 'обновлять состояние команды');
    }
    
    $res = 'Неизвестная ошибка обновления состояния команды '.$this->Team->name;

    // Возможно игра уже закончилась.
    if ($this->Game->status >= Game::GAME_FINISHED)
    {
      if ($this->status <= TeamState::TEAM_WAIT_TASK)
      {
        // Нет текущего задания, можно финишировать сразу.
        $res = $this->finish($actor);
      }
      else
      {
        // Разберемся, что можно сделать с текущим заданием.
        if ($currentTaskStatus = $this->getCurrentTaskState())
        {
          if ($currentTaskStatus->status < TaskState::TASK_ACCEPTED)
          {
            // Задание еще неизвестно команде, просто прекратим его
            $this->abandonTask($actor);
            // и финишируем команду
            $res = $this->finish($actor);
          }
          else
          {
            // Ничего не делаем, обновление задания само догадается о завершении игры.
          }
        }
        else
        {
          // Задание должно быть, но не найдено, просто финишируем команду.
          $res = $this->finish($actor);
        }
      }
    }

    switch ($this->status)
    {

      // Команда ждет начала игры.
      case TeamState::TEAM_WAIT_GAME:
        if ($this->Game->isActive())
        {
          // Если игра началась, то команда должна дождаться своей очереди на старт.
          $this->status = TeamState::TEAM_WAIT_START;
        }
        $res = true;
        break;

      // Команда ждет своей очереди для старта.
      case TeamState::TEAM_WAIT_START:
        if (($this->Game->isActive()) && (time() >= $this->getActualStartDateTime()))
        {
//          $res = $this->reset($actor);
          $res = /*($res === true) ? */$this->start($actor)/* : $res*/;
        }
        else
        {
          $res = true;
        }
        break;

      // Команда ждет следующего задания.
      case TeamState::TEAM_WAIT_TASK:
        //Если игровое время исчерпано
        if ($this->getGameSpentTimeCurrent() >= $this->Game->time_per_game * 60)
        {
          //То выдавать следующее задание нельзя, финишируем.
          $res = $this->finish($actor);
        }  
        else
        {
          if ($this->task_id > 0)
          {
            // Следующее задание уже назначено, надо его сделать текущим.
            $nextTask = $this->Task;
            // Задание попытаемся выдать только один раз, если не получится, его надо будет назначить заново.
            $this->Task = null;
            $res = $this->giveTask($nextTask, $actor);
          }
          else
          {
            // Следующее задание еще не назначено.
            $availableTasks = $this->getAvailableTasks();
            if (!$availableTasks)
            {
              // У команды нет доступных заданий, значит она завершила игру.
              $res = $this->finish($actor);
            }
            else
            {
              if ($this->ai_enabled)
              {
                $this->autoSelectNextTask();
              }
              $res = true;
            }
          }
        }
        break;

      // Команда выполняет задание
      case TeamState::TEAM_HAS_TASK:
        if ($currentTaskStatus = $this->getCurrentTaskState())
        {
          if ($currentTaskStatus->status >= TaskState::TASK_DONE)
          {
            // Задание завершено с каким-либо результатом.
            $res = $this->closeTask($actor);
          }
          else
          {
            // Держать здесь! Выполнять только ПОСЛЕ проверки на завершение.
            $res = $currentTaskStatus->updateState($actor);
          }
        }
        else
        {
          //Текущее задание потеряно. Будем ждать следующего.
          $this->status = TeamState::TEAM_WAIT_TASK;
          $res = true;
        }
        break;

      case TeamState::TEAM_FINISHED:
      default:
        $res = true;
        break;
    }

    $this->team_last_update = time();
    $this->save();
    return $res;
  }

  /**
   * Сбрасывает состояние команды на предстартовое.
   * ВНИМАНИЕ: не сохраняет изменения в БД. Save() выполняет вызывающая сторона.
   *
   * @param   WebUser   $actor      Исполнитель
   * @return  mixed                 True при успехе, иначе строка с ошибкой.
   */
  public function reset(WebUser $actor)
  {
    // Сбрасывать состояние может только руководитель
    if (!$this->Game->canBeManaged($actor))
    {
      return Utils::cannotMessage($actor->login, Permission::byId(Permission::GAME_MODER)->description);
    }

    // Сбросим счетчик времени
    $this->game_time_spent = 0;
    // Сбросим текущее задание
    $this->task_state_id = 0;
    // Удалим все достижения 
    foreach ($this->taskStates as $taskState)
    {
      $taskState->delete();
    }

    $this->status = TeamState::TEAM_WAIT_GAME;
    $this->team_last_update = time();
    return true;
  }

  /**
   * Выполняет старт команды.
   * ВНИМАНИЕ: не сохраняет изменения в БД. Save() выполняет вызывающая сторона.
   *
   * @param   WebUser   $actor      Исполнитель
   * @return  mixed                 True при успехе, иначе строка с ошибкой.
   */
  public function start(WebUser $actor)
  {
    if (!$this->canUpdateState($actor))
    {
      return Utils::cannotMessage($actor->login, 'обновлять состояние команды');
    }
    if ($this->status > TeamState::TEAM_WAIT_START)
    {
      return 'Команда '.$this->Team->name.' уже стартовала в игре '.$this->Game->name;
    }
    // Запомним реальное время старта
    $this->started_at = time();
    // Сбросим текущее задание
    $this->task_state_id = 0;
    // Разрешим получать задания
    $this->status = TeamState::TEAM_WAIT_TASK;

    $this->team_last_update = time();
    return true;
  }

  /**
   * Фиксирует финиш команды.
   * ВНИМАНИЕ: не сохраняет изменения в БД. Save() выполняет вызывающая сторона.
   *
   * @param   WebUser   $actor      Исполнитель
   * @return  mixed                 True при успехе, иначе строка с ошибкой.
   */
  public function finish(WebUser $actor)
  {
    if (!$this->canUpdateState($actor))
    {
      return Utils::cannotMessage($actor->login, 'обновлять состояние команды');
    }
    if ($this->status >= TeamState::TEAM_FINISHED)
    {
      return 'Команда '.$this->Team->name.' уже финишировала в игре '.$this->Game->name;
    }
    // Определим время финиша по времени выполнения последнего успешного задания
    $this->finished_at = 0;
    foreach ($this->taskStates as $taskState)
    {
      if (($taskState->status == TaskState::TASK_DONE_SUCCESS)
          && ($this->finished_at < $taskState->done_at))
      {
        $this->finished_at = $taskState->done_at;
      }
    }
    // Если не нашли ни одного выполненного задания, то финиш по времени остановки игры или по текущему.
    if ($this->finished_at == 0)
    {
      $this->finished_at = ($this->Game->finished_at > 0)
          ? $this->Game->finished_at
          : time();
    }
    $this->status = TeamState::TEAM_FINISHED;

    $this->team_last_update = time();
    return true;
  }

  /**
   * Назначает команде следующее задание (не путать с выдачей нового).
   * ВНИМАНИЕ: не сохраняет изменения в БД. Save() выполняет вызывающая сторона.
   * Внимание: Задание не считается стартовавшим, пока команда его не увидит!
   *
   * @param   mixed     $task   Задание или null для отмены выбора
   * @param   WebUser   $actor  Исполнитель
   * @return  mixed             True при успехе, иначе строка с ошибкой.
   */
  public function setNextTask($task, WebUser $actor)
  {
    if (!$this->canUpdateState($actor))
    {
      return Utils::cannotMessage($actor->login, 'обновлять состояние команды');
    }
    if ($task == null)
    { // Выполняется отмена выбора следующего задания
      $this->Task = null;
    }
    else
    { // Назначим следующее задание
      if ($this->isKnownTask($task))
      {
        return 'Команда '.$this->Team->name.' уже выполняла задание '.$task->name;
      }
      $this->task_id = $task->id;
    }
  }

  /**
   * Выдает команде задание к исполнению.
   * ВНИМАНИЕ: Сохраняет в БД только статус нового задания. Save() выполняет вызывающая сторона.
   *
   * @param   Task      $task   Задание
   * @param   WebUser   $actor  Исполнитель
   * @return  mixed             True при успехе, иначе строка с ошибкой.
   */
  public function giveTask(Task $task, WebUser $actor)
  {
    if (!$this->canUpdateState($actor))
    {
      return Utils::cannotMessage($actor->login, 'обновлять состояние команды');
    }
    if ($currentTaskStatus = $this->getCurrentTaskState())
    {
      return 'Команда '.$this->Team->name.' еще не закончила задание '.$currentTaskStatus->Task->name;
    }
    if ($this->isKnownTask($task))
    {
      return 'Команда '.$this->Team->name.' уже получала задание '.$task->name;
    }
    $newStatus = new TaskState();
    $newStatus->team_state_id = $this->id;
    $newStatus->task_id = $task->id;
    $newStatus->given_at = time();
    $newStatus->started_at = 0;
    $newStatus->accepted_at = 0;
    $newStatus->task_idle_time = 0;
    $newStatus->done_at = 0;
    $newStatus->closed = false;
    $newStatus->status = TaskState::TASK_GIVEN;
    $newStatus->task_time_spent = 0;
    $newStatus->task_last_update = time();
    $newStatus->save(); //Опасно!! Но по другому не получится получить реальный id новой записи для... (1)
    $this->taskStates->add($newStatus);
    $this->task_state_id = $newStatus->id; //(1)... использования здесь

    $this->status = TeamState::TEAM_HAS_TASK;
    $this->team_last_update = time();
    return true;
  }

  /**
   * Подтверждает завершение задания.
   * Не меняет уже имеющийся статус задания, который отражает результат выполнения задания.
   * ВНИМАНИЕ: Сохраняет в БД только статус закрытого задания. Save() выполняет вызывающая сторона.
   *
   * @param   WebUser   $actor  Исполнитель
   * @return  mixed             True при успехе, иначе строка с ошибкой.
   */
  public function closeTask(WebUser $actor)
  {
    if (!$this->canUpdateState($actor))
    {
      return Utils::cannotMessage($actor->login, 'обновлять состояние команды');
    }
    if ($currentTaskStatus = $this->getCurrentTaskState())
    {
      if ($currentTaskStatus->status < TaskState::TASK_DONE)
      {
        return 'Команда '.$this->Team->name.' еще выполняет задание '.$currentTaskStatus->Task->name;
      }
    }
    else
    {
      return 'У команды '.$this->Team->name.' нет текущего задания';
    }

    $currentTaskStatus->closed = true;
    $currentTaskStatus->save();
    $this->task_state_id = 0;

    $this->status = TeamState::TEAM_WAIT_TASK;
    $this->updateTime();
    return true;
  }

  /**
   * Отменяет текущее задание команды. Если она с ним уже ознакомилась, то
   * завершает задание с признаком отмены. Если не успела - просто убирает
   * задание из истории.
   * ВНИМАНИЕ: Сохраняет в БД состояние и команды и задания.
   *
   * @param   WebUser   $actor  Исполнитель
   * @return  mixed             True при успехе, иначе строка с ошибкой.
   */
  public function abandonTask(WebUser $actor)
  {
    // Отменять состояние может только руководитель
    if (!$this->Game->canBeManaged($actor))
    {
      return Utils::cannotMessage($actor->login, Permission::byId(Permission::GAME_MODER)->description);
    }
    if (!($currentTaskStatus = $this->getCurrentTaskState()))
    {
      return true;
    }

    //Если задание не было просмотрено, то его надо просто убрать
    if ($currentTaskStatus->status < TaskState::TASK_ACCEPTED)
    {
      $currentTaskStatus->delete();
      $this->task_state_id = 0;
      $this->save();
      $this->status = TeamState::TEAM_WAIT_TASK;
    }
    //Задание было просмотрено, его надо завершить корректно
    elseif ($currentTaskStatus->status >= TaskState::TASK_DONE)
    {
      return 'Текущее задание уже завершено.';
    }
    else
    {
      $currentTaskStatus->status = TaskState::TASK_DONE_ABANDONED;
      $currentTaskStatus->done_at = time();
      $currentTaskStatus->task_time_spent = 0;
      $currentTaskStatus->save();
      //Задание будет закрыто в следующем цикле пересчета.
    }

    $this->updateTime();
    return true;
  }

  //// Self ////

  /**
   * Выполняет выбор следующего задания на основе текущей ситуации.
   * Результат устанавливается в качестве следующего задания команды.
   * Если задание уже установлено - не меняет его.
   * Если задание выбрать не удастся - ничего не делает.
   */
  protected function autoSelectNextTask()
  {
     //Если команде уже назначено следующее задание
    if ($this->task_id > 0)
    {
      return;
    }    
    //Определим текущие приоритеты заданий и максимальный приоритет.
    $candidates = array();
    $candidatesCount = 0;
    $maxPriority = null;
    foreach ($this->Game->tasks as $task)
    {
      $candidate = array();
      $candidate['task_id'] = $task->id;
      $priority = $this->getPriorityOfTask($task);
      if ($priority !== false)
      {
        $candidate['priority'] = $priority;
        if ($priority > $maxPriority)
        {
          $maxPriority = $priority;
        }
        array_push($candidates, $candidate);
        $candidatesCount++;
      }
    };
    //Нет ни одного доступного задания?
    if ($candidatesCount == 0)
    {
      return;
    }
    //Доступно только одно задание? Тогда выбирать не приходится.
    if ($candidatesCount == 1)
    {
      $this->task_id = $candidates[0]['task_id'];
      $this->save();
      return;
    }
    //Отсортируем результаты
    
    //В начале списка - задания с максимальным приоритетом, возьмем его.
    $maxPriority = $candidates[0]['priority'];
    
    //Выберем задания с максимальным приоритетом и сосчитаем их.
    $candidates2 = array();
    $candidates2MaxIndex = 0;
    foreach ($candidates as $candidate)
    {
      if ($candidate['priority'] == $maxPriority)
      {
        array_push($candidates2, $candidate);
        $candidates2MaxIndex++;
      }
    }
    
    //Выберем случайное из отобранных заданий в качестве следующего.
    $this->task_id = $candidates[rand(0, $candidates2MaxIndex - 1)]['task_id'];
    $this->save();
    return;
  }
  
  /**
   * Проверяет, играет ли команда в данный момент
   */
  protected function isPlayingNow()
  {
    return $this->status < TeamState::TEAM_FINISHED;
  }

  /**
   * Пересчитывает игровое время по завершенным заданиям.
   */
  protected function updateTime()
  {
    // Рассчитаем затраченное на игре время как сумму времен известных заданий.
    // Завершенные значения вернут данные из БД, текущее задание само сосчитает.
    $timeSpent = 0;
    foreach ($this->taskStates as $taskState)
    {
      $timeSpent += $taskState->getTaskSpentTimeCurrent();
    }
    $this->game_time_spent = $timeSpent;
  }

}